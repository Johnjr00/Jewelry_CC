<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Jewelry Case Inventory</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">

  <style>
    :root{
      --bg: #0b1220;
      --panel: rgba(255,255,255,.08);
      --panel2: rgba(255,255,255,.06);
      --stroke: rgba(255,255,255,.12);
      --text: rgba(255,255,255,.92);
      --muted: rgba(255,255,255,.78);
      --radius: 18px;
    }

    body{
      font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background: radial-gradient(1200px 800px at 20% 0%, #7f1d1d 0%, #1a0b0b 55%, #070308 100%);
      color: var(--text);
    }

    .glass{
      background: var(--panel);
      border: 1px solid var(--stroke);
      border-radius: var(--radius);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }
    .glass-soft{
      background: var(--panel2);
      border: 1px solid var(--stroke);
      border-radius: var(--radius);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }

    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }

    .btn, .form-control, .form-select, .alert { border-radius: 16px; }
    .form-control, .form-select, textarea{ background: rgba(255,255,255,.92); color:#111; border-color: rgba(0,0,0,.08);} 
    .form-control::placeholder{ color: rgba(0,0,0,.45); }
    .form-control:focus, .form-select:focus, textarea:focus{
      background: rgba(255,255,255,.98);
      color: #111;
    }
    .form-control:disabled, .form-select:disabled, textarea:disabled,
    .form-control[readonly], textarea[readonly]{
      background: rgba(255,255,255,.85);
      color: #111;
      opacity: 1;
    }
    .form-control, .form-select { padding: .9rem .95rem; }
    .btn { padding: .8rem 1rem; font-weight: 600; }

    .topbar{
      position: sticky;
      top: 0;
      z-index: 50;
      background: rgba(7,11,20,.75);
      border-bottom: 1px solid rgba(255,255,255,.10);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
    }

    .chip{
      display:inline-flex;
      align-items:center;
      gap:.4rem;
      padding:.35rem .6rem;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      color: var(--muted);
      font-size: .85rem;
      white-space: nowrap;
    }

    .case-tile{
      min-height: 116px;
      border-radius: 22px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      transition: transform .08s ease, background .08s ease;
      text-decoration: none;
      color: var(--text);
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      padding: 14px 14px 12px 14px;
    }
    .case-tile:hover{ transform: translateY(-1px); background: rgba(255,255,255,.085); color: var(--text); }
    .case-code{ font-size: 1.35rem; font-weight: 800; letter-spacing: .02em; }
    .case-name{ color: var(--muted); font-size: .95rem; }
    .case-meta{ color: rgba(255,255,255,.72); font-size: .86rem; display:flex; gap:.5rem; flex-wrap: wrap; }

    .divider{ border-top: 1px solid rgba(255,255,255,.12); }

    /* Strong, consistent contrast for tables on dark glass backgrounds */
    .table{
      color: var(--text);
      --bs-table-color: var(--text);
      --bs-table-bg: transparent;
      --bs-table-border-color: rgba(255,255,255,.12);
      --bs-table-striped-bg: rgba(255,255,255,.03);
      --bs-table-striped-color: var(--text);
      --bs-table-hover-bg: rgba(255,255,255,.06);
      --bs-table-hover-color: var(--text);
    }
    .table thead th{
      color: rgba(255,255,255,.78);
      font-weight: 700;
      border-color: rgba(255,255,255,.14);
    }
    .table tbody td{
      border-color: rgba(255,255,255,.12);
      color: var(--text);
    }
    .table-hover tbody tr:hover{
      background: rgba(255,255,255,.06);
    }

    /* Bootstrap's text-white-50 can get too faint on tablets; bump it slightly */
    .text-white-50{ color: rgba(255,255,255,.78) !important; }

    /* Links: keep them readable on the dark red background */
    a{ color: rgba(255,255,255,.90); }
    a:hover{ color: #fff; }

    /* Dropdowns/menus if any future pages add them */
    .dropdown-menu{
      background: rgba(15,15,20,.95);
      border: 1px solid rgba(255,255,255,.14);
      color: var(--text);
    }
    .dropdown-item{ color: var(--text); }
    .dropdown-item:hover, .dropdown-item:focus{
      background: rgba(255,255,255,.08);
      color: #fff;
    }

    @media (min-width: 992px){
      .sticky-actions{ position: sticky; top: 92px; }
    }
  </style>
</head>

<body>
  <div class="topbar">
    <div class="container-fluid px-3 py-3 d-flex align-items-center justify-content-between">
      <a class="text-decoration-none text-white fw-bold fs-5" href="{{ url_for('index') }}">Jewelry Inventory</a>

      {% if user %}
      <div class="d-flex align-items-center gap-2">
        <span class="chip d-none d-md-inline">ðŸ‘¤ {{ user.username }} Â· {{ user.role }}</span>
        <a class="btn btn-outline-light btn-sm" href="{{ url_for('index') }}">Home</a>
        <a class="btn btn-outline-light btn-sm" href="{{ url_for('logout') }}">Logout</a>
      </div>
      {% endif %}
    </div>

    {% if user %}
    <div class="container-fluid px-3 pb-3">
      <div class="d-flex flex-wrap gap-2">
        <a class="btn btn-outline-light" href="{{ url_for('index') }}">Home</a>
        <a class="btn btn-outline-light" href="{{ url_for('counts') }}">Counts</a>
        <a class="btn btn-light" href="{{ url_for('receive') }}">Receive</a>
        <a class="btn btn-light" href="{{ url_for('move') }}">Move</a>
        <a class="btn btn-warning" href="{{ url_for('sell') }}">Sell</a>
        <a class="btn btn-danger" href="{{ url_for('missing') }}">Missing</a>
        <a class="btn btn-outline-light" href="{{ url_for('history') }}">History</a>
        <a class="btn btn-outline-light" href="{{ url_for('export_inventory') }}">Export Inventory CSV</a>
          <a class="btn btn-outline-light" href="{{ url_for('daily_activity_reports') }}">Daily Reports</a>
        {% if user.role == 'admin' %}
          <a class="btn btn-outline-light" href="{{ url_for('users') }}">Users</a>
        {% endif %}
      </div>
    </div>
    {% endif %}
  </div>

  <div class="container-fluid px-3 py-3">
    {% with messages = get_flashed_messages(with_categories=true) %}
      {% if messages %}
        {% for category, message in messages %}
          <div class="alert alert-{{ category }} glass-soft border-0 text-white" role="alert">
            {{ message }}
          </div>
        {% endfor %}
      {% endif %}
    {% endwith %}

    {% block content %}{% endblock %}
  </div>

  <div class="modal fade" id="upcScannerModal" tabindex="-1" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered modal-lg">
      <div class="modal-content glass border-0">
        <div class="modal-header border-0">
          <h5 class="modal-title">Scan UPC</h5>
          <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body">
          <div class="ratio ratio-16x9 glass-soft overflow-hidden">
            <div id="upcScannerViewport" class="w-100 h-100 position-relative">
              <video id="upcScannerVideo" class="w-100 h-100" autoplay muted playsinline></video>
            </div>
          </div>
          <div class="text-white-50 mt-3" data-role="status"></div>
          <div class="text-white-50 mt-1 d-none" data-role="support">
            Barcode scanning needs a browser with BarcodeDetector support (Safari 16+ recommended).
          </div>
          <div class="mt-3 d-none" data-role="capture">
            <button class="btn btn-outline-light" type="button" data-role="capture-btn">Capture Photo</button>
            <input class="visually-hidden" data-role="capture-input" type="file" accept="image/*" capture="environment">
            <div class="text-white-50 mt-2">
              If the live camera preview is unavailable, take a photo of the barcode instead.
            </div>
          </div>
        </div>
        <div class="modal-footer border-0">
          <button class="btn btn-outline-light" type="button" data-bs-dismiss="modal">Close</button>
        </div>
      </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
  <script>
    window.addEventListener("load", () => {
      const el = document.querySelector("[data-autofocus='true']");
      if (el) el.focus();
    });

    window.addEventListener("load", () => {
      const scanButtons = document.querySelectorAll("[data-upc-scan-target]");
      if (!scanButtons.length) return;

      const modalEl = document.getElementById("upcScannerModal");
      const videoEl = document.getElementById("upcScannerVideo");
      const statusEl = modalEl.querySelector("[data-role='status']");
      const supportEl = modalEl.querySelector("[data-role='support']");
      const captureEl = modalEl.querySelector("[data-role='capture']");
      const captureBtn = modalEl.querySelector("[data-role='capture-btn']");
      const captureInput = modalEl.querySelector("[data-role='capture-input']");
      const viewportEl = document.getElementById("upcScannerViewport");
      const modal = new bootstrap.Modal(modalEl);
      let activeInput = null;
      let activeStream = null;
      let scanning = false;
      let detector = null;
      let rafId = null;
      let scanCanvas = null;
      let scanCtx = null;
      let quaggaActive = false;
      let quaggaHandler = null;

      const formats = ["upc_a", "upc_e", "ean_13", "ean_8"];

      const stopStream = () => {
        if (activeStream) {
          activeStream.getTracks().forEach((track) => track.stop());
          activeStream = null;
        }
        if (videoEl) {
          videoEl.srcObject = null;
        }
      };

      const stopQuagga = async () => {
        if (!quaggaActive) return;
        try {
          const Quagga = window.Quagga;
          if (Quagga) {
            if (quaggaHandler && Quagga.offDetected) {
              Quagga.offDetected(quaggaHandler);
            }
            Quagga.stop();
          }
        } catch (error) {
          // Ignore cleanup errors.
        }
        quaggaActive = false;
        quaggaHandler = null;
        if (viewportEl) {
          viewportEl.querySelectorAll("canvas").forEach((canvas) => canvas.remove());
        }
      };

      const normalizeBarcodeValue = (value) => {
        if (!value) return value;
        const trimmed = value.trim();
        const digitsOnly = trimmed.replace(/\D/g, "");
        if (!digitsOnly) return trimmed;
        if (digitsOnly.length === 13 && digitsOnly.startsWith("0")) {
          return digitsOnly.slice(1);
        }
        return digitsOnly.length >= 12 ? digitsOnly : trimmed;
      };

      const appendValue = (value) => {
        if (!activeInput) return;
        const normalized = normalizeBarcodeValue(value);
        if (activeInput.tagName === "TEXTAREA") {
          const current = activeInput.value || "";
          const next = current.trim()
            ? `${current.replace(/\s*$/, "")}\n${normalized}`
            : normalized;
          activeInput.value = next;
        } else {
          activeInput.value = normalized;
        }
        activeInput.dispatchEvent(new Event("input", { bubbles: true }));
        activeInput.focus();
      };

      const ensureDetector = () => {
        if (!("BarcodeDetector" in window)) {
          return null;
        }
        if (!detector) {
          detector = new BarcodeDetector({ formats });
        }
        return detector;
      };

      const showCaptureFallback = (message) => {
        statusEl.textContent = message;
        captureEl.classList.remove("d-none");
        supportEl.classList.add("d-none");
      };

      const loadImageElement = (file) =>
        new Promise((resolve, reject) => {
          const img = new Image();
          const url = URL.createObjectURL(file);
          img.onload = () => {
            URL.revokeObjectURL(url);
            resolve(img);
          };
          img.onerror = () => {
            URL.revokeObjectURL(url);
            reject(new Error("Image load failed."));
          };
          img.src = url;
        });

      const loadQuagga = (() => {
        let promise = null;
        return () => {
          if (window.Quagga) {
            return Promise.resolve(window.Quagga);
          }
          if (promise) {
            return promise;
          }
          promise = new Promise((resolve, reject) => {
            const script = document.createElement("script");
            script.src = "https://cdn.jsdelivr.net/npm/@ericblade/quagga2@1.2.6/dist/quagga.min.js";
            script.async = true;
            script.onload = () => resolve(window.Quagga);
            script.onerror = () => reject(new Error("Quagga load failed."));
            document.head.appendChild(script);
            setTimeout(() => reject(new Error("Quagga load timed out.")), 8000);
          });
          return promise;
        };
      })();

      const decodeWithDetector = async (file) => {
        const detectorInstance = ensureDetector();
        if (!detectorInstance) return [];
        let source = null;
        if ("createImageBitmap" in window) {
          try {
            source = await createImageBitmap(file, { imageOrientation: "from-image" });
          } catch (error) {
            source = null;
          }
        }
        if (!source) {
          source = await loadImageElement(file);
        }
        const width = source.naturalWidth || source.width || source.displayWidth;
        const height = source.naturalHeight || source.height || source.displayHeight;
        if (!width || !height) return [];
        const maxOutput = 3500;
        const maxDim = Math.max(width, height);
        const scales = [1, 1.5, 2, 2.5];
        for (const scaleUp of scales) {
          let scale = Math.min(1, maxOutput / maxDim);
          scale *= scaleUp;
          if (maxDim * scale > maxOutput) {
            scale = maxOutput / maxDim;
          }
          if (!Number.isFinite(scale) || scale <= 0) continue;
          const canvas = document.createElement("canvas");
          canvas.width = Math.round(width * scale);
          canvas.height = Math.round(height * scale);
          const ctx = canvas.getContext("2d");
          if (!ctx) continue;
          ctx.drawImage(source, 0, 0, canvas.width, canvas.height);
          const barcodes = await detectorInstance.detect(canvas);
          if (barcodes && barcodes.length) {
            return barcodes;
          }
        }
        return [];
      };

      const decodeWithQuagga = async (file) => {
        const Quagga = await loadQuagga();
        if (!Quagga) {
          return [];
        }
        let source = null;
        if ("createImageBitmap" in window) {
          try {
            source = await createImageBitmap(file, { imageOrientation: "from-image" });
          } catch (error) {
            source = null;
          }
        }
        if (!source) {
          source = await loadImageElement(file);
        }

        const getSize = (imgSource) => {
          const width = imgSource.naturalWidth || imgSource.width || imgSource.displayWidth;
          const height = imgSource.naturalHeight || imgSource.height || imgSource.displayHeight;
          return { width, height };
        };

        const toCanvas = (imgSource, maxSize, scaleUp = 1) => {
          const { width, height } = getSize(imgSource);
          if (!width || !height) return null;
          const maxDim = Math.max(width, height);
          const maxOutput = 3000;
          let scale = maxSize ? Math.min(1, maxSize / maxDim) : 1;
          scale *= scaleUp;
          if (maxDim * scale > maxOutput) {
            scale = maxOutput / maxDim;
          }
          if (!Number.isFinite(scale) || scale <= 0) return null;
          const canvas = document.createElement("canvas");
          canvas.width = Math.round(width * scale);
          canvas.height = Math.round(height * scale);
          const ctx = canvas.getContext("2d");
          if (!ctx) return null;
          ctx.drawImage(imgSource, 0, 0, canvas.width, canvas.height);
          return canvas;
        };

        const scanAttempts = [
          { maxSize: 3200, scaleUp: 1, locator: { patchSize: "small", halfSample: false } },
          { maxSize: 2600, scaleUp: 1, locator: { patchSize: "medium", halfSample: false } },
          { maxSize: 2200, scaleUp: 1, locator: { patchSize: "large", halfSample: false } },
          { maxSize: 1800, scaleUp: 1, locator: { patchSize: "medium", halfSample: true } },
          { maxSize: 1400, scaleUp: 1, locator: { patchSize: "large", halfSample: true } },
          { maxSize: 1600, scaleUp: 1.5, locator: { patchSize: "small", halfSample: false } },
          { maxSize: 1200, scaleUp: 2, locator: { patchSize: "small", halfSample: false } },
          { maxSize: 900, scaleUp: 2.5, locator: { patchSize: "small", halfSample: false } },
        ];
        for (const attempt of scanAttempts) {
          const canvas = toCanvas(source, attempt.maxSize, attempt.scaleUp);
          if (!canvas) continue;
          const dataUrl = canvas.toDataURL("image/jpeg", 0.95);
          const result = await Promise.race([
            new Promise((resolve) => {
              Quagga.decodeSingle(
                {
                  src: dataUrl,
                  numOfWorkers: 0,
                  locate: true,
                  inputStream: { size: Math.max(canvas.width, canvas.height) },
                  locator: attempt.locator,
                  decoder: {
                    readers: ["upc_reader", "upc_e_reader", "ean_reader", "ean_8_reader"],
                  },
                },
                (decoded) => resolve(decoded)
              );
            }),
            new Promise((resolve) => setTimeout(() => resolve(null), 6000)),
          ]);
          if (result && result.codeResult && result.codeResult.code) {
            return [{ rawValue: result.codeResult.code }];
          }
        }
        return [];
      };

      const scanLoop = () => {
        if (!scanning || !detector) return;
        if (!scanCanvas) {
          scanCanvas = document.createElement("canvas");
          scanCtx = scanCanvas.getContext("2d");
        }
        if (!scanCtx) return;
        const width = videoEl.videoWidth;
        const height = videoEl.videoHeight;
        if (!width || !height) {
          rafId = requestAnimationFrame(scanLoop);
          return;
        }
        if (scanCanvas.width !== width || scanCanvas.height !== height) {
          scanCanvas.width = width;
          scanCanvas.height = height;
        }
        scanCtx.drawImage(videoEl, 0, 0, width, height);
        detector
          .detect(scanCanvas)
          .then((barcodes) => {
            if (barcodes && barcodes.length) {
              const rawValue = barcodes[0].rawValue;
              appendValue(rawValue);
              statusEl.textContent = `Captured ${normalizeBarcodeValue(rawValue)}`;
              scanning = false;
              modal.hide();
            }
          })
          .catch(() => {})
          .finally(() => {
            if (scanning) {
              rafId = requestAnimationFrame(scanLoop);
            }
          });
      };

      const startQuaggaScan = async () => {
        statusEl.textContent = "Starting cameraâ€¦";
        supportEl.classList.add("d-none");
        captureEl.classList.add("d-none");
        videoEl.classList.add("d-none");
        await stopStream();
        const Quagga = await loadQuagga();
        if (!Quagga) {
          showCaptureFallback("Live scanning is unavailable. Use photo capture instead.");
          return;
        }
        quaggaHandler = (result) => {
          if (!result || !result.codeResult || !result.codeResult.code) return;
          const rawValue = result.codeResult.code;
          appendValue(rawValue);
          statusEl.textContent = `Captured ${normalizeBarcodeValue(rawValue)}`;
          modal.hide();
        };
        return new Promise((resolve) => {
          Quagga.init(
            {
              inputStream: {
                type: "LiveStream",
                target: viewportEl,
                constraints: {
                  facingMode: "environment",
                  width: { ideal: 1280 },
                  height: { ideal: 720 },
                },
              },
              locator: { patchSize: "medium", halfSample: true },
              decoder: { readers: ["upc_reader", "upc_e_reader", "ean_reader", "ean_8_reader"] },
            },
            (err) => {
              if (err) {
                showCaptureFallback("Live scanning is unavailable. Use photo capture instead.");
                resolve();
                return;
              }
              quaggaActive = true;
              Quagga.onDetected(quaggaHandler);
              Quagga.start();
              scanning = true;
              statusEl.textContent = "Point the camera at the UPC barcode.";
              resolve();
            }
          );
        });
      };

      const startScan = async () => {
        statusEl.textContent = "Starting cameraâ€¦";
        supportEl.classList.add("d-none");
        captureEl.classList.add("d-none");
        if (!window.isSecureContext) {
          showCaptureFallback("Live camera access requires HTTPS. Use photo capture instead.");
          return;
        }
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
          showCaptureFallback("Live camera access is not available in this browser.");
          return;
        }
        const detectorInstance = ensureDetector();
        if (!detectorInstance) {
          await startQuaggaScan();
          return;
        }
        videoEl.classList.remove("d-none");
        try {
          videoEl.setAttribute("playsinline", "");
          videoEl.setAttribute("webkit-playsinline", "");
          videoEl.playsInline = true;
          videoEl.muted = true;
          activeStream = await navigator.mediaDevices.getUserMedia({
            video: {
              facingMode: { ideal: "environment" },
              width: { ideal: 1280 },
              height: { ideal: 720 },
            },
            audio: false,
          });
          videoEl.srcObject = activeStream;
          await new Promise((resolve) => {
            if (videoEl.readyState >= 1) {
              resolve();
              return;
            }
            videoEl.onloadedmetadata = () => resolve();
          });
          await videoEl.play();
        } catch (err) {
          showCaptureFallback("Camera access was blocked. Use photo capture instead.");
          return;
        }
        scanning = true;
        statusEl.textContent = "Point the camera at the UPC barcode.";
        scanLoop();
      };

      captureBtn.addEventListener("click", () => {
        captureInput.value = "";
        captureInput.click();
      });

      captureInput.addEventListener("change", async (event) => {
        const file = event.target.files && event.target.files[0];
        if (!file) return;
        statusEl.textContent = "Scanning photoâ€¦";
        try {
          let barcodes = await decodeWithDetector(file);
          if (!barcodes || !barcodes.length) {
            barcodes = await decodeWithQuagga(file);
          }
          if (barcodes && barcodes.length) {
            const rawValue = barcodes[0].rawValue;
            appendValue(rawValue);
            statusEl.textContent = `Captured ${normalizeBarcodeValue(rawValue)}`;
            modal.hide();
          } else {
            statusEl.textContent = "No barcode detected in the photo. Try again.";
            supportEl.classList.remove("d-none");
          }
        } catch (error) {
          statusEl.textContent = "Could not read the photo. Try again.";
          supportEl.classList.remove("d-none");
        }
      });

      modalEl.addEventListener("hidden.bs.modal", () => {
        scanning = false;
        if (rafId) {
          cancelAnimationFrame(rafId);
          rafId = null;
        }
        stopQuagga();
        stopStream();
        videoEl.classList.remove("d-none");
        statusEl.textContent = "";
        captureInput.value = "";
      });

      scanButtons.forEach((btn) => {
        btn.addEventListener("click", () => {
          const targetId = btn.getAttribute("data-upc-scan-target");
          const target = document.getElementById(targetId);
          if (!target) return;
          activeInput = target;
          modal.show();
          startScan();
        });
      });
    });
  </script>
</body>
</html>
